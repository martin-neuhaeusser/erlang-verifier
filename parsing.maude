***(

	PARSING.MAUDE

	This module defines a meta level functional module that represents the Core-Erlang syntax
	definition. The metaParse function (included from META-LEVEL) uses the grammar defined here
	to parse Core-Erlang source-code that is input as a list of quoted identifiers.
	Due to limitations in the current implementation, we have to insert whitespaces into the
	Core-Erlang code as generated by the erlang compiler before and after those characters
	(when they are used as brackets or to separate atoms, etc.)
				"/", ":", "<", ">"
	These characters are not recognized as separators by the Maude parser. Therefore Core-Erlang 
	function names, written without whitespace, such as "funname/2" would be treated as one quoted
	identifier instead of the "_/_" operator of arity two in mix-fix notation. Such an interpretation
	leads to syntax errors, of course.
	
***)

----------------------------------------------------------------------------------------------------
---
--- PRINT-SYNTAX-ERROR
---
--- Some functions to print out the position at which a syntax error is reported by
--- the metaParse function. This code is taken from the Full-Mode implementation.
---
----------------------------------------------------------------------------------------------------

fmod PRINT-SYNTAX-ERROR is
	protecting META-LEVEL .
	protecting INT .

	var  QIL : QidList .
	var  Q : Qid .
	var  N : Nat .
	vars RP RP' : ResultPair .
	var  RP? : [ResultPair?] .

	op printN : Nat QidList -> QidList .  *** first N qid's in a qidList
	eq printN(N, nil) = nil .
	eq printN(0, QIL) = nil .
	eq printN(s N, Q QIL) = Q printN(N, QIL) . 

	op removeFront : Nat QidList -> QidList .  *** removes first N qid's
	eq removeFront(N, nil) = nil .
	eq removeFront(0, QIL) = QIL .
	eq removeFront(s N, Q QIL) = removeFront(N, QIL) .

	op printSyntaxError : [ResultPair?] QidList -> QidList .
	eq printSyntaxError(noParse(N), QIL) 
		= '\r 'Parse 'error 'in '\o '\s printN(N + 1, QIL) '\r '<---*HERE* '\o .
	eq printSyntaxError(ambiguity(RP, RP'), QIL) 
		= '\r 'Ambiguous 'parsing 'for '\o '\s QIL '\o .
	eq printSyntaxError(RP?, QIL) = QIL [owise] . 
endfm

----------------------------------------------------------------------------------------------------
---
--- SYNTAX-HELPER
---
----------------------------------------------------------------------------------------------------

fmod SYNTAX-HELPER is 
	protecting RAT .
	protecting FLOAT .
	protecting INT .
	protecting STRING .
	protecting CONVERSION .
	protecting QID .
	protecting META-LEVEL .

	*** core-erlang atoms
	op syntaxCheckAtom : Term -> Bool .
	op getAtom : Term -> String .
	
	*** core-erlang variable names
	op syntaxCheckVar : Term -> Bool .
	op getVar : Term -> String .
	
	*** core-erlang characters
	op syntaxCheckChar : Term -> Bool .
	op getChar : Term -> Char .
	
	*** core-erlang strings
	op syntaxCheckString : Term -> Bool .
	op getString : Term -> String .
	
	*** core-erlang integers
	op syntaxCheckInt : Term -> Bool .
	op getInt : Term -> Int .

	*** core-erlang floats
	op syntaxCheckFloat : Term -> Bool .
	op getFloat : Term -> Float .

	sort CharSet .
	subsort Char < CharSet .
	op _,_ : CharSet CharSet -> CharSet [ctor comm assoc] .
	op intCharSet : -> CharSet .
	op signCharSet : -> CharSet .
	op stringCharSet : -> CharSet .
	op characterSet : String CharSet -> Bool .

	op downQid : Qid -> Qid .
		
	var Str : String .
	var T : Term .
	var QID : Qid .
	var EndPos : Int .
	var Chr Chr1 Chr2 : Char .
	var Set : CharSet .

	eq intCharSet = "0","1","2","3","4","5","6","7","8","9" .
	eq signCharSet = "-", "+" .
	
	eq characterSet("", Set) = true .
	eq characterSet(Chr, Chr1) = if (Chr == Chr1) then true else false fi .
	eq characterSet(Chr, (Chr1, Set)) = if (Chr == Chr1) then true else characterSet(Chr, Set) fi .
	eq characterSet(Str, Set) = 
		if characterSet(substr(Str, 0, 1), Set) then characterSet(substr(Str, 1, length(Str) + (-1)), Set) else false fi .

	ceq downQid( QID ) = qid(substr(Str, 1, length(Str))) 
		if Str := string(QID) /\ substr(Str, 0, 1) == "'" .

	*** core-erlang atoms
	ceq syntaxCheckAtom('token[T]) = (substr(Str, 0, 1) == "'") and (substr(Str, EndPos, 1) == "'") 
		if Str := string(downQid(getName(T))) /\ EndPos := length(Str) + (-1) .
	ceq getAtom('token[T]) = substr(Str, 1, EndPos) 
	  	if Str := string(downQid(getName(T))) /\ EndPos := length(Str) + (-2) /\ syntaxCheckAtom('token[T]) .
	  
	*** core-erlang variable names
	ceq syntaxCheckVar('token[T]) = ((ascii(Chr) >= 65) and (ascii(Chr) <= 90)) or (ascii(Chr) == 95)
	  	if Chr := substr(string(downQid(getName(T))), 0, 1) .
	ceq getVar('token[T]) = string(downQid(getName(T))) 
	  	if syntaxCheckVar('token[T]) .
	  
	*** core-erlang characters
	ceq syntaxCheckChar('token[T]) = (substr(Str, 0, 1) == "'") and (substr(Str, 2, 1) == "'") 
	  	if Str := string(downQid(getName(T))) /\ (length(Str) == 2) .
	ceq getChar('token[T]) = substr(Str, 1, 1) 
	  	if Str := string(downQid(getName(T))) /\ syntaxCheckAtom('token[T]) .
	
	*** core-erlang strings
	ceq syntaxCheckString('token[T]) = (substr(Str, 0, 1) == "\"") and (substr(Str, EndPos, 1) == "\"")
		if Str := string(downQid(getName(T))) /\ EndPos := length(Str) + (-1) .
	ceq getString('token[T]) = string(downQid(getName(T))) 
		if syntaxCheckString('token[T]) .	
	  
	*** core-erlang integers
	ceq syntaxCheckInt('token[T]) = (characterSet(substr(Str, 0, 1), signCharSet) and characterSet(substr(Str, 1, length(Str) + (-1)), intCharSet)) 
	                                 or (characterSet(substr(Str,0,length(Str)), intCharSet)) 
		if Str := string(downQid(getName(T))) .
	ceq getInt('token[T]) = rat(string(downQid(getName(T))),10) 
		if syntaxCheckInt('token[T]) .		
	
	*** core-erlang floats 
	*** - not implemented -
	
	*** core-erlang token lists
	*** - not implemented -
endfm

----------------------------------------------------------------------------------------------------
---
--- COMMON-SYNTAX-DOWN
---
--- This functional module converts the Core-Erlang program from the meta-level (level 1)
--- back to the object level (level 0).
---
----------------------------------------------------------------------------------------------------

fmod COMMON-SYNTAX-DOWN is
	protecting SYNTAX .
	protecting QID .
	protecting META-TERM .	
	protecting META-LEVEL .
	protecting STRING .
	protecting INT .
	protecting CONVERSION .
	protecting SYNTAX-HELPER .

	
	op GRAMMAR : -> FModule .
	
	op #downModule : Term -> ErlModule [memo] .
	
	op #downAtom : Term -> Atom [memo] .
	op #downVar : Term -> Atom [memo] .
	op #downErlInt : Term -> ErlInt [memo] .

	op #downModuleBody : Term -> ModuleBody [memo] .
	op #downNeFunDefList : Term -> NeFunDefList [memo] .

	op #downFunDef : Term -> FunDef [memo] .
	op #downFun : Term -> Fun [memo] .
	op #downFunName : Term -> FunName [memo] .

	op #downTimeoutClause : Term -> TimeoutClause [memo] .

	op #downNeVarList : Term -> NeVarList [memo] .
	op #downExpr : Term -> Expr [memo] .

	op #downClause : Term -> Clause [memo] .
	op #downPatterns : Term -> Patterns [memo] .

	op #downNeClauseList : Term -> NeClauseList [memo] .
	op #downVariables : Term -> Variables [memo] .	
	op #downVarSeq : Term -> VarSeq [memo] .

	op #downOSeq : Term -> OSeq [memo] .
	op #downNeSingleExprList : Term -> NeSingleExprList [memo] .

	op #downSingleExpr : Term -> SingleExpr [memo] .

	op #downNeExprList : Term -> NeExprList [memo] .

	op #downList : Term -> ErlList [memo] .
	op #downTuple : Term -> ErlTuple [memo] .

	vars T1 T2 T3 T4 : Term .
	var SUB : Substitution .
	
	eq #downModule('module_`[_`]__end[T1,T2,T3,T4]) = module #downAtom(T1) [] attributes [] #downModuleBody(T4) end .

	eq #downModuleBody(T1) = #downNeFunDefList(T1) .
	
	eq #downNeFunDefList('_/_=_[T1,T2,T3]) = #downFunDef('_/_=_[T1,T2,T3]) .
	ceq #downNeFunDefList(T1) = #downFunDef(T2) #downNeFunDefList(T3) 
		if SUB := metaMatch(GRAMMAR, '__['F:FunDef, 'FL:NeFunDefList], T1, nil, 0) 
		/\ 'F:FunDef <- T2 ; 'FL:NeFunDefList <- T3 := SUB .
	
	eq #downFunDef('_/_=_[T1,T2,T3]) = #downAtom(T1) / #downErlInt(T2) = #downFun(T3) .

	eq #downFun('fun`(_`)->_[T1,T2]) = fun(#downNeVarList(T1)) -> #downExpr(T2) .
	eq #downFun('fun`(`)->_[T1]) = fun() -> #downExpr(T1) .

	eq #downFunName('_/_[T1,T2]) = #downExpr(T1) / #downExpr(T2) .

	eq #downTimeoutClause('after_->_[T1,T2]) = after #downExpr(T1) -> #downExpr(T2) .

	ceq #downNeVarList(T1) = #downVar(T2) , #downNeVarList(T3)
		if SUB := metaMatch(GRAMMAR, '_`,_['V:Var, 'VL:NeVarList], T1, nil, 0)
		/\ 'V:Var <- T2 ; 'VL:NeVarList <- T3 := SUB .
	eq #downNeVarList(T1) = #downVar(T1) [owise] .

	eq #downExpr('<>.EmptySeq) = <> .
	eq #downExpr('<_>[T1]) = #downOSeq('<_>[T1]) .
	eq #downExpr(T1) = #downSingleExpr(T1) .
	
	eq #downVariables(T1) = #downVarSeq(T1) .
	
	eq #downVarSeq('<>.EmptySeq) = <> .
	eq #downVarSeq('<_>[T1]) = #downNeVarList(T1) .
	eq #downVarSeq(T1) = #downVar(T1) .
	
	eq #downOSeq('<>.EmptySeq) = <> .
	eq #downOSeq('<_>[T1]) = < #downNeSingleExprList(T1) > .

	ceq #downNeSingleExprList(T1) = #downSingleExpr(T2), #downNeSingleExprList(T3)
		if SUB := metaMatch(GRAMMAR, '_`,_['E:SingleExpr, 'EL:NeSingleExprList], T1, nil, 0)
		/\ 'E:SingleExpr <- T2 ; 'EL:NeSingleExprList <- T3 := SUB .
	eq #downNeSingleExprList(T1) = #downSingleExpr(T1) [owise] .
		
	ceq #downNeExprList(T1) = #downExpr(T2), #downNeExprList(T3)
		if SUB := metaMatch(GRAMMAR, '_`,_['E:Expr, 'EL:NeExprList], T1, nil, 0)
		/\ 'E:Expr <- T2 ; 'EL:NeExprList <- T3 := SUB .
	eq #downNeExprList(T1) = #downExpr(T1) [owise] .

	ceq #downNeClauseList(T1) = #downClause(T2) #downNeClauseList(T3)
		if SUB := metaMatch(GRAMMAR, '__['C:Clause, 'CL:NeClauseList], T1, nil, 0)
		/\ 'C:Clause <- T2 ; 'CL:NeClauseList <- T3 := SUB .
	eq #downNeClauseList(T1) = #downClause(T1) [owise] .

	eq #downClause('_when_->_[T1,T2,T3]) = #downPatterns(T1) when #downExpr(T2) -> #downExpr(T3) .

	eq #downPatterns('<>.EmptySeq) = <> .
	eq #downPatterns('<_>[T1]) = < #downNeExprList(T1) > .
	eq #downPatterns(T1) = #downExpr(T1) [owise] .
	
	eq #downSingleExpr('case_of_end[T1,T2]) = case #downExpr(T1) of #downNeClauseList(T2) end .
	eq #downSingleExpr('let_=_in_[T1,T2,T3]) = let #downVariables(T1) = #downExpr(T2) in #downExpr(T3) .
	eq #downSingleExpr('letrec_in_[T1,T2]) = letrec #downNeFunDefList(T1) in #downExpr(T2) .
	eq #downSingleExpr('call_:_`(`)[T1,T2]) = call #downAtom(T1) : #downAtom(T2) () .
	eq #downSingleExpr('call_:_`(_`)[T1,T2,T3]) = call #downAtom(T1) : #downAtom(T2) (#downNeExprList(T3)) .
	eq #downSingleExpr('apply_`(`)[T1]) = apply #downSingleExpr(T1) () .
	eq #downSingleExpr('apply_`(_`)[T1,T2]) = apply #downSingleExpr(T1) (#downNeExprList(T2)) .
	eq #downSingleExpr('do__[T1,T2]) = do #downExpr(T1) #downExpr(T2) .
	eq #downSingleExpr('receive__[T1,T2]) = receive #downNeClauseList(T1) #downTimeoutClause(T2) .
	eq #downSingleExpr('fun`(`)->_[T1]) = #downFun('fun`(`)->_[T1]) .
	eq #downSingleExpr('fun`(_`)->_[T1,T2]) = #downFun('fun`(_`)->_[T1,T2]) .
	eq #downSingleExpr('_/_[T1,T2]) = #downFunName('_/_[T1,T2]) .
	eq #downSingleExpr('`[`].Nil) = [] .

	eq #downSingleExpr('`{_`}[T1]) = #downTuple('`{_`}[T1]) .
	eq #downSingleExpr('`{`}.TupleConstl) = {} .

	eq #downSingleExpr('`[_`][T1]) = #downList('`[_`][T1]) .
	eq #downSingleExpr('`[_|_`][T1,T2]) = #downList('`[_|_`][T1,T2]) .
	
	eq #downSingleExpr('<>.EmptySeq) = <> .

	eq #downSingleExpr('primop_`(_`)[T1,T2]) = primop #downAtom(T1) (#downNeExprList(T2)) .
	eq #downSingleExpr('primop_`(`)[T1]) = primop #downAtom(T1) () .

	eq #downSingleExpr('catch_[T1]) = catch #downExpr(T1) .
	
	eq #downTuple('`{_`}[T1]) = {#downNeExprList(T1)} .
	eq #downTuple('`{`}.TupleConst) = {} .
	
	eq #downList('`[_`][T1]) = [#downNeExprList(T1)] .
	eq #downList('`[_|_`][T1,T2]) = [#downExpr(T1) | #downExpr(T2)] .
endfm

fmod PARSING-SYNTAX-DOWN is
	including COMMON-SYNTAX-DOWN .
	
	op #downErlString : Term -> ListConst [memo]  .
	op #downErlChar : Term -> ErlInt [memo] .

	eq GRAMMAR = 
		(mod 'GRAMMAR is
			including 'QID-LIST .
			including 'COMMAND-GRAMMAR .
			including 'PARSING-SYNTAX .
			including 'PREDICATES .
			including 'LTL-FORMULAE .
			sorts none .        
			none 
			op 'token : 'Qid -> 'Token
				[ctor special(
					(id-hook('Bubble, '1 '1)
					 op-hook('qidSymbol, '<Qids>, nil, 'Qid)
					 id-hook('Exclude, 'module 'end '-| '-> 'attributes 'catch 'do 
					 		   'receive 'after 'try 'of 'case 'let 'letrec 
							   'fun 'primop 'apply 'when '`[ '`] '`, '`. '= '/ 
							   '/ '< '> '`( '`) '`} '`{ '`{`} '`(`) '`[`] '<>)))
				format ('b 'o)] .
			none
			none 
			none
		endm) .	
		
	var T : Term .
	var INT : Int .
	var STR : String .
	
	eq #downAtom('token[T]) = atom(substr(string(getName(T)), 2, length(string(getName(T))) + (-3))) .
	eq #downVar('token[T]) = var(substr(string(getName(T)), 1, length(string(getName(T))))) .
	eq #downErlInt('token[T]) = int(rat(substr(string(getName(T)), 1, length(string(getName(T)))), 10)) .	
	
	eq #downErlString('token[T]) 
		= #builtStringList(substr(string(getName(T)), 2, length(string(getName(T))) + (-3))) .
	
	op #builtStringList : String -> ListConst .
	
	eq #builtStringList("") = [] .
	eq #builtStringList(STR) 
		= [ int(ascii(substr(STR, 0, 1))) | #builtStringList(substr(STR, 1, length(STR) + -1))] [owise] .
	
	ceq #downSingleExpr('token[T]) = #downAtom('token[T])
		if syntaxCheckAtom('token[T]) .
	ceq #downSingleExpr('token[T]) = #downVar('token[T])
		if syntaxCheckVar('token[T]) .
	ceq #downSingleExpr('token[T]) = #downErlInt('token[T])
		if syntaxCheckInt('token[T]) .
	ceq #downSingleExpr('token[T]) = #downErlString('token[T])
		if syntaxCheckString('token[T]) .
endfm

fmod MAUDE-SYNTAX-DOWN is
	protecting META-UP-DOWN .
	including COMMON-SYNTAX-DOWN .

	eq GRAMMAR = 
		(mod 'GRAMMAR is
			including 'QID-LIST .
			including 'SYNTAX .
			including 'SEM_PROCESSES .
			including 'SEM_MODENV .
			including 'SEM_PID_SEQUENCE .					
			including 'SEM_MAILBOX .
			including 'PREDICATES .
			including 'LTL-FORMULAE .
			sorts none .        
			none 
			none
			none
			none 
			none
		endm) .		
		
	var T : Term .
	
	eq #downAtom('atom[T]) = atom(#downString(T)) .
	eq #downVar('var[T]) = var(#downString(T)) .
	eq #downErlInt('int[T]) = int(#downInt(T)) .
	
	eq #downSingleExpr('atom[T]) = atom(#downString(T)) .
	eq #downSingleExpr('var[T]) = var(#downString(T)) .
	eq #downSingleExpr('int[T]) = int(#downInt(T)) .
endfm

fmod MAUDE-SYNTAX-UPDOWN is
	protecting MAUDE-SYNTAX-UP .
	protecting MAUDE-SYNTAX-DOWN .
endfm 
